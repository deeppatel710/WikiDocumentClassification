













Sprite (computer graphics) - Wikipedia, the free encyclopedia














/*<![CDATA[*/
		var skin = "monobook";
		var stylepath = "/skins-1.5";
		var wgArticlePath = "/wiki/$1";
		var wgScriptPath = "/w";
		var wgScript = "/w/index.php";
		var wgVariantArticlePath = false;
		var wgActionPaths = {};
		var wgServer = "http://en.wikipedia.org";
		var wgCanonicalNamespace = "";
		var wgCanonicalSpecialPageName = false;
		var wgNamespaceNumber = 0;
		var wgPageName = "Sprite_(computer_graphics)";
		var wgTitle = "Sprite (computer graphics)";
		var wgAction = "view";
		var wgArticleId = "913509";
		var wgIsArticle = true;
		var wgUserName = null;
		var wgUserGroups = null;
		var wgUserLanguage = "en";
		var wgContentLanguage = "en";
		var wgBreakFrames = false;
		var wgCurRevisionId = 279798094;
		var wgVersion = "1.15alpha";
		var wgEnableAPI = true;
		var wgEnableWriteAPI = true;
		var wgSeparatorTransformTable = ["", ""];
		var wgDigitTransformTable = ["", ""];
		var wgMWSuggestTemplate = "http://en.wikipedia.org/w/api.php?action=opensearch\x26search={searchTerms}\x26namespace={namespaces}\x26suggest";
		var wgDBname = "enwiki";
		var wgSearchNamespaces = [0];
		var wgMWSuggestMessages = ["with suggestions", "no suggestions"];
		var wgRestrictionEdit = [];
		var wgRestrictionMove = [];
		/*]]>*/
<!-- wikibits js -->



/*<![CDATA[*/
var wgNotice='';var wgNoticeLocal='';
/*]]>*/ 
<!-- site js -->






if (wgNotice != '') document.writeln(wgNotice); Sprite (computer graphics)

From Wikipedia, the free encyclopedia

Jump to: navigation, search 







This article has multiple issues. Please help improve the article or discuss these issues on the talk page.

It does not cite any references or sources. Please help improve it by citing reliable sources. Tagged since September 2007.
It may require general cleanup to meet Wikipedia's quality standards. Tagged since October 2007.





In computer graphics, a sprite (also known by other names; see Synonyms below) is a two-dimensional/three-dimensional image or animation that is integrated into a larger scene.
Sprites were originally invented as a method of quickly compositing several images together in two-dimensional video games using special hardware. As computer performance improved, this optimization became unnecessary and the term evolved to refer specifically to the two dimensional images themselves that were integrated into a scene. That is, figures generated by either custom hardware or by software alone were all referred to as sprites. As three-dimensional graphics became more prevalent, the term was used to describe a technique whereby flat images are seamlessly integrated into complicated three-dimensional scenes.




Contents


1 History

1.1 Hardware sprites
1.2 Sprites by software
1.3 Background
1.4 Move to 3D


2 Application
3 Synonyms





//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>


[edit] History
In the mid-1970s, Signetics devised the first video/graphics processors capable of generating sprite graphics. The Signetics 2636 video processors were first used in the 1976 Radofin 1292 Advanced Programmable Video System.
The Elektor TV Games Computer was the first PC capable of generating sprite graphics, which Signetics referred to as "objects". The term "sprite" was coined for the Texas Instruments TMS9918 [1].
During most of the 1980s, hardware speed was in the low, single-digit megahertz and memory was measured in kilobytes. Beside CISC processors, all chips are hardwired. Sprites are rare in most video hardware today.
The CPU can instruct the external chips to fetch source images and integrate them into the main screen using direct memory access channels. Calling up external hardware, instead of using the processor alone, greatly improved graphics performance. Because the processor is not occupied by the simple task of transferring data from one place to another, software can run faster; and because the hardware provided certain innate abilities, programs that use CISC or BIOS were also smaller.
Separate locations in memory were used to hold the main display and the sprites. Some sprite engines could only store a small amount of positions in their registers and the unchallenged CPU was programmed to update them several times per frame. Software blitting was complicated by some very strange addressing modes into video ram.

[edit] Hardware sprites
In early video gaming, sprites were a method of integrating unrelated bitmaps so that they appear to be part of a single bitmap on a screen.
Many early graphics chips had true spriting use capabilities in which the sprite images were integrated into the screen, often with priority control with respect to the background graphics, at the time the video signal was being generated by the graphics chip. This improved performance greatly since the sprite data did not need to be copied into the video memory in order to appear on the screen, and further since this spared the programmer of the task of having to save and restore the underlying graphics, something which otherwise was needed if the programmer chose to progressively update.
The sprite engine is a hardware implementation of scanline rendering. For each scanline the appropriate scanlines of the sprites are first copied (the number of pixels is limited by the memory bandwidth and the length of the horizontal retrace) into very fast, small, multiple (limiting the # of sprites on a line), and costly caches (the size of which limit the horizontal width) and as the pixels are sent to the screen, these caches are combined with each other and the background. It may be larger than the screen and is usually tiled, where the tile map is cached, but the tile set is not. For every pixel, every sprite unit signals its presence onto its line on a bus, so every other unit can notice a collision with it. Some sprite engines can automatically reload their "sprite units" from a display list. The sprite engine has synergy with the palette. To save registers, the height of the sprite, the location of the texture, and the zoom factors are often limited. On systems where the word size is the same as the texel there is no penalty for doing unaligned reads needed for rotation. This leads to the limitations of the known implementations:

Sprite Hardware Features

Computer, chip
Sprites on screen
Sprites on line
Max texels on line
Texture width
Texture height
Colors
Hardware Zoom
Rotation
Background
Collision detection
Transparency
Source


Amiga, Denise
display list
8
?
16
arbitrary
3,15
vertical by display list
No
2 bitmap layers
Yes
color key



Amiga(AGA), Lisa
display list
8
?
16,32,64
arbitrary
3,15
vertical by display list
No
2 bitmap layers
Yes
color key



Atari, ANTIC
display list
4
?
2,8
128, 256
1,3
1,2x vertical, 1,2,4x horizontal
No
1 tile or bitmap layer
Yes
color key
[2]


C64, VIC-II
display list run by CPU
8
?
12,24
21
1,3
1x 2x integer
No
1 tile or bitmap layer
Yes
color key
[3]


Game Boy
40
10
80
8
8,16
3
No
No
1 tile layer
No
color key
[4]


GBA
128
128
1210
8,16,32,64
8,16,32,64
15,255
Affine
Affine
4 layers, 2 layers + 1 affine layer, 2 affine layers
No
color key, blending
[5]


NES, RP2C0x
64
8
64
8
8,16
3
No
No
1 tile layer
Partial
color key
[6]


Neo Geo
384
96
1536
16
Up to 512
15
sprite shrinking
No
No
No
color key
.


Out Run, dedicated hardware
128
32
?
8
8
?
Anisotropic
No
3 tile layers
?
alpha
[7], [8]


PC Engine, HuC6270A
64
16
256
16,32
16,32,64
15
No
No
1 tile layer
Yes
color key



Sega Master System
Sega Game Gear
64
8
64
8
8,16
15
No
No
1 tile layer
Yes
color key
[9]


Sega Mega Drive
80
20
320
8,16,24,32
8,16,24,32
15
No
No
2 tile layers
?
color key
[10]


SNES
128
34
272
8,16,32,64
8,16,32,64
15
background only
background only
affine mapped tiles
?
color key, averaging



Texas Instruments TMS9918
32
4
64
8,16
8,16
1
1x 2x integer
No
1 tile layer
Partial
color key
[11]


Yamaha V9938
32
8
?
?
?
16
No
No
?
?
color key



Computer, chip
Sprites on screen
Sprites on line
Max texels on line
Texture width
Texture height
Colors
Hardware Zoom
Rotation
Background
Collision detection
Transparency
Source



Many third party graphics cards offered sprite capabilities. Sprite engines often scale badly, starting to flicker as the number of sprites increases above the number of sprite units, or uses more and more silicon as the designer of the chip implements more units and bigger caches.

[edit] Sprites by software
Many popular home computers of the 1980's lack any support for sprites by hardware. The animated characters, bullets, pointing cursors, etc. for videogames (mainly) were rendered exclusively with the CPU by software, as part of the screen video memory in itself. Hence the term software sprites.
Mainly, two distinct techniques were used to render the sprites by software, depending on the display hardware characteristics:

Binary image masks, mainly for systems with bitmapped video frame buffers. It implies the use of an additional binary mask for every sprite displayed.
Transparent color, mainly for systems with indexed color displays. It implies that the "transparent" pixels use a concrete palette entry color, specifically reserved for this purpose by the program.


[edit] Background




Example of a sprite.


No sprite engine was implemented which would not cache the sprites texels, but use a FIFO at the pixel-output instead. This would allow sprites of arbitrary width. So while blitter based hardware uses a unified model for foreground and background and a fixed flat frame-buffer, sprites need a special background engine. It has to provide scrolling backgrounds for tile-based games and pseudo-3D (mode 7) backgrounds.
A similar discrimination is known from software rendering. A technique called "dirty rectangles" is used to redraw only those parts that have changed since the last repainted and a scrolling frame buffer is used. On more powerful CPUs the whole frame-buffer is flat and redrawn completely.

[edit] Move to 3D
Prior to the popularizing of true 3D graphics in the late 1990s, many 2D games attempted to imitate the look of three-dimensionality with a variety of sprite production methods. These included:

Rotoscoping: The filmed performances of live actors were sometimes used for creating sprites, most famously in the case of Prince of Persia which added a relative element of realism to a platform game. The method was used in a number of other fighting games, mostly in the mid 90s.
Claymation or the use of posable models which were used for characters that could not be portrayed by actors. Famous early examples include Goro of Mortal Kombat and various enemies from Doom. Used to a greater extent in games like Clay Fighter.
Pre-rendered CGI models: Introduced by Rise of the Robots and later used to a great extent in PC real-time strategy and RPG games prior to the move to true 3D. Since computers of the day could not run complex 3D graphics, footage of pre-rendered three-dimensional character models were often used which created a (relative) illusion of 3D.

More often sprite now refers to a partially transparent two dimensional animation that is mapped onto a special plane in a 3D scene. Unlike a texture map, the sprite plane is always perpendicular to the axis emanating from the camera. The image can be scaled to simulate perspective, rotated two dimensionally, overlapped with other objects, and be occluded, but it can only be viewed from the same angle. This rendering method is also referred to as billboarding.
Sprites create an effective illusion when

the image inside the sprite already depicts a three dimensional object;
the animation is constantly changing or depicts rotation;
the sprite exists only shortly;
the depicted object has a similar appearance from many common viewing angles (such as something spherical);
the viewer accepts that the depicted object only has one perspective (such as small plants or leaves).

When the illusion works, viewers will not notice that the sprite is flat and always faces them. Often sprites are used to depict phenomena such as fire, smoke, small objects, small plants (like blades of grass), or special symbols (like "1-Up"). The sprite illusion can be exposed in video games by quickly changing the position of the camera while keeping the sprite in the center of the view. Sprites are also used extensively in particle effects and commonly represented pickups in early 3D games especially.
An example of extensive usage of sprites to create the illusion is the game The Elder Scrolls IV: Oblivion, whose main graphical feature was the ability to display hundreds, if not thousands of animated trees on-screen at one time. Closer inspection of those trees reveals that the leaves are in fact sprites, and rotate along with the position of the user. However, this fact is only revealed when the player actually examines the trees up-close, and rotates the camera.
Sprites have also occasionally been used as a special-effects tool in movies. One such example is the fire breathing Balrog in The Lord of the Rings: The Fellowship of the Ring; the effects designers utilized sprites to simulate fire emanating from the surface of the demon. Small bursts of fire were filmed in front of a black background and made transparent using a luma key. Many bursts were then attached to the surface of the animated Balrog model and mixed with simulated smoke and heat waves to create the illusion of a monster made from fire.
The term "sprite" is often confused with low resolution 2D graphics drawn on a computer, also known as pixel art. However, sprite graphics (bitmaps) can be created from any imaginable source, including prerendered CGI, dynamic 3D graphics, vector art, and even text. Likewise, pixel art is created for many purposes other than as a sprite, such as video game backgrounds, textures, icons, websites, display art, comics, and t-shirts.
With the advancement in computer graphics and improved power and resolution, actual pixel art sprites are becoming increasingly infrequent outside of handheld game systems and cell phones.

[edit] Application
Sprites are typically used for characters and other moving objects in video games. They have also been used for mouse pointers and for writing letters to the screen. For on-screen moving objects larger than one sprite's extent, sprites may sometimes be scaled and/or combined.
Billboarding is one term used to describe the use of sprites in a 3D environment. In the same way that a billboard is positioned to face drivers on a highway, the 3D sprite always faces the camera. There is both a performance advantage and an aesthetic advantage to using billboarding. Most 3D rendering engines can process "3D sprites" much faster than other types of 3D objects. So it is possible to gain an overall performance improvement by substituting sprites for some objects that might normally be modeled using texture mapped polygons. Aesthetically sprites are sometimes desirable because it can be difficult for polygons to realistically reproduce phenomena such as fire. In such situations, sprites provide a more attractive illusion.

[edit] Synonyms
Major video game companies rarely (if at all) use the term "sprite" in the general public. Some other alternatives that have been used are:

Player-Missile Graphics was used on the Atari 400/800 and Early Atari Coin Op games to refer to hardware-generated sprites. The term reflected the usage for both characters ("players") and other objects ("missiles"). They had restricted horizontal resolution (8 or 2 pixels, albeit with scalability, and a potential 192 lines of vertical resolution), limiting their use somewhat.
Movable Object Block, or MOB was used in MOS Technology's graphics chip literature (data sheets, etc). However, Commodore, the main user of MOS chips and the owner of MOS for most of the chip maker's lifetime, applied the common term "sprite".
On the Nintendo Entertainment System, Super Nintendo Entertainment System, and Game Boy, sprites were referred to as OBJs (short for "objects"), and the region of RAM used to store sprite attributes and coordinates was known as OAM (Object Attribute Memory). This still applies today on the Game Boy Advance and Nintendo DS handheld systems.
BOB's or 'Blitter Objects', popular name for graphics objects drawn with the dedicated graphics blitter in the Amiga series of computers, which was available in addition to its true hardware sprites.
Software sprites were used to refer to subroutines that used bit blitting to accomplish the same goal on systems such as the Atari ST and the Apple II whose graphics hardware had no sprite capability.
The computer programming language DarkBASIC used the term Bob (for "blitter object") to refer to its software-sprite functions, before switching to the more conventionally-used "sprite" term.
3D Sprite is a term often used to refer to sprites that are essentially texture mapped 3D facets that always have their surface normal facing into the camera.
Z-Sprite is a term often used for 3D environments that contain only sprites. The Z-parameter provides a scaling effect that creates an illusion of depth. For example in adventure games such as King's Quest VI where the camera never moves, normal 2D sprites might suffice, but Z-sprites provide an extra touch.
Impostor is a term used instead of billboard if the billboard is meant to subtly replace a real 3D object.




Retrieved from "http://en.wikipedia.org/wiki/Sprite_(computer_graphics)"
Categories: Computer graphics data structures | Video game designHidden categories: Articles lacking sources from September 2007 | All articles lacking sources | Cleanup from October 2007 | All pages needing cleanup 






Views


Article
Discussion
Edit this page
History 



Personal tools


Log in / create account






 if (window.isMSIE55) fixalpha(); 

Navigation


Main page
Contents
Featured content
Current events
Random article




Search




 
				




Interaction


About Wikipedia
Community portal
Recent changes
Contact Wikipedia
Donate to Wikipedia
Help




Toolbox


What links here
Related changes
Upload file
Special pages
Printable version Permanent linkCite this page 



Languages


Česky
Dansk
Deutsch
Español
Français
Italiano
Nederlands
‪Norsk (bokmål)‬
日本語
Polski
Português
Русский
Suomi
Svenska









 This page was last modified on 26 March 2009, at 13:50.
All text is available under the terms of the GNU Free Documentation License. (See Copyrights for details.)  Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a U.S. registered 501(c)(3) tax-deductible nonprofit charity.
Privacy policy
About Wikipedia
Disclaimers



if (window.runOnloadHook) runOnloadHook();
