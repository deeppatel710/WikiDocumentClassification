













Exception handling - Wikipedia, the free encyclopedia














/*<![CDATA[*/
		var skin = "monobook";
		var stylepath = "/skins-1.5";
		var wgArticlePath = "/wiki/$1";
		var wgScriptPath = "/w";
		var wgScript = "/w/index.php";
		var wgVariantArticlePath = false;
		var wgActionPaths = {};
		var wgServer = "http://en.wikipedia.org";
		var wgCanonicalNamespace = "";
		var wgCanonicalSpecialPageName = false;
		var wgNamespaceNumber = 0;
		var wgPageName = "Exception_handling";
		var wgTitle = "Exception handling";
		var wgAction = "view";
		var wgArticleId = "59231";
		var wgIsArticle = true;
		var wgUserName = null;
		var wgUserGroups = null;
		var wgUserLanguage = "en";
		var wgContentLanguage = "en";
		var wgBreakFrames = false;
		var wgCurRevisionId = 274818696;
		var wgVersion = "1.15alpha";
		var wgEnableAPI = true;
		var wgEnableWriteAPI = true;
		var wgSeparatorTransformTable = ["", ""];
		var wgDigitTransformTable = ["", ""];
		var wgMWSuggestTemplate = "http://en.wikipedia.org/w/api.php?action=opensearch\x26search={searchTerms}\x26namespace={namespaces}\x26suggest";
		var wgDBname = "enwiki";
		var wgSearchNamespaces = [0];
		var wgMWSuggestMessages = ["with suggestions", "no suggestions"];
		var wgRestrictionEdit = [];
		var wgRestrictionMove = [];
		/*]]>*/
<!-- wikibits js -->



/*<![CDATA[*/
var wgNotice='';var wgNoticeLocal='';
/*]]>*/ 
/*<![CDATA[*/
.source-csharp {line-height: normal;}
.source-csharp li, .source-csharp pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for csharp
 * CSS class: source-csharp, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-csharp .de1, .source-csharp .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-csharp  {}
.source-csharp .head {}
.source-csharp .foot {}
.source-csharp .imp {font-weight: bold; color: red;}
.source-csharp .ln-xtra {color: #cc0; background-color: #ffc;}
.source-csharp li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-csharp li.li2 {font-weight: bold;}
.source-csharp .kw1 {color: #0600FF;}
.source-csharp .kw2 {color: #FF8000; font-weight: bold;}
.source-csharp .kw3 {color: #008000;}
.source-csharp .kw4 {color: #FF0000;}
.source-csharp .kw5 {color: #000000;}
.source-csharp .co1 {color: #008080; font-style: italic;}
.source-csharp .co2 {color: #008080;}
.source-csharp .coMULTI {color: #008080; font-style: italic;}
.source-csharp .es0 {color: #008080; font-weight: bold;}
.source-csharp .br0 {color: #008000;}
.source-csharp .st0 {color: #808080;}
.source-csharp .nu0 {color: #FF0000;}
.source-csharp .me1 {color: #0000FF;}
.source-csharp .me2 {color: #0000FF;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
/*<![CDATA[*/
.source-eiffel {line-height: normal;}
.source-eiffel li, .source-eiffel pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for eiffel
 * CSS class: source-eiffel, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter)
 */
.source-eiffel .de1, .source-eiffel .de2 {font-family: 'Courier New', Courier, monospace; font-weight: normal;}
.source-eiffel  {}
.source-eiffel .head {}
.source-eiffel .foot {}
.source-eiffel .imp {font-weight: bold; color: red;}
.source-eiffel .ln-xtra {color: #cc0; background-color: #ffc;}
.source-eiffel li {font-family: 'Courier New', Courier, monospace; color: black; font-weight: normal; font-style: normal;}
.source-eiffel li.li2 {font-weight: bold;}
.source-eiffel .kw1 {color: #0600FF; font-weight: bold;}
.source-eiffel .kw2 {color: #0600FF; font-weight: bold;}
.source-eiffel .kw3 {color: #800080;}
.source-eiffel .kw4 {color: #800000}
.source-eiffel .kw5 {color: #603000;}
.source-eiffel .co1 {color: #008000; font-style: italic;}
.source-eiffel .coMULTI {}
.source-eiffel .es0 {color: #005070; font-weight: bold;}
.source-eiffel .br0 {color: #600000;}
.source-eiffel .st0 {color: #0080A0;}
.source-eiffel .nu0 {color: #FF0000;}
.source-eiffel .me1 {color: #000060;}
.source-eiffel .me2 {color: #000050;}

/*]]>*/

/*<![CDATA[*/
@import "/w/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=2678400";
/*]]>*/
 <!-- site js -->






if (wgNotice != '') document.writeln(wgNotice); Exception handling

From Wikipedia, the free encyclopedia

Jump to: navigation, search 
Exception handling is a programming language construct or computer hardware mechanism designed to handle the occurrence of exceptions - special conditions that change the normal flow of execution.
Unlike signals and event handlers that are part of the normal program flow, exceptions are typically used to signal that something went wrong (e.g. a division by zero occurred or a required file was not found). Exceptions are raised or thrown (initiated) by either the hardware or the program itself by using a special command.
In general, an exception is handled (resolved) by saving the current state of execution in a predefined place and switching the execution to a specific subroutine - an exception handler. Depending on the situation, the handler may later resume the execution at the original location using the saved information. For example, a page fault will usually allow the program to be resumed, while a division by zero might not be resolvable transparently.
From the processing point of view, hardware interrupts are similar to resumable exceptions, though they are typically unrelated to the user's program flow.
From the point of view of the author of a routine, raising an exception is a useful way to signal that a routine could not execute normally. For example, when an input argument is invalid (a zero denominator in division) or when a resource it relies on is unavailable (like a missing file, or a hard disk error). In systems without exceptions, routines would need to return some special error code. However, this is sometimes complicated by the semipredicate problem, in which users of the routine need to write extra code to distinguish normal return values from erroneous ones.
In runtime engine environments such as Java or .NET, there exist tools that attach to the runtime engine and every time that an exception of interest occurs, they record debugging information that existed in memory at the time the exception was thrown (call stack and heap values). These tools are called Automated Exception Handling or Error Interception tools and provide 'root-cause' information for exceptions.
Contemporary applications face many design challenges when considering exception handling strategies. Particularly in modern enterprise level applications, exceptions must often cross process boundaries and machine boundaries. Part of designing a solid exception handling strategy is recognizing when a process has failed to the point where it cannot be economically handled by the software portion of the process. At such times, it is very important to present exception information to the appropriate stakeholders. [1]




Contents


1 Exception safety

1.1 Verification of Exception Handling


2 Exception support in programming languages
3 Exception handling based on Design by Contract
4 Checked exceptions

4.1 Pros and cons


5 Exception synchronity
6 Condition systems

6.1 Continuable exceptions
6.2 Restarts separate mechanism from policy


7 See also
8 References
9 External links





//<![CDATA[
 if (window.showTocToggle) { var tocShowText = "show"; var tocHideText = "hide"; showTocToggle(); } 
//]]>


[edit] Exception safety
A piece of code is said to be exception-safe, if run-time failures within the code will not produce ill effects, such as memory leaks, garbled stored data, or invalid output. Exception-safe code must satisfy invariants placed on the code even if exceptions occur. There are several levels of exception safety:

Failure transparency, also known as the no throw guarantee: Operations are guaranteed to succeed and satisfy all requirements even in presence of exceptional situations. If an exception occurs, it will not throw the exception further up. (Best level of exception safety.)
Commit or rollback semantics, also known as strong exception safety or no-change guarantee: Operations can fail, but failed operations are guaranteed to have no side effects so all data retain original values.[2]
Basic exception safety: Partial execution of failed operations can cause side effects, but invariants on the state are preserved. Any stored data will contain valid values even if data has different values now from before the exception.
Minimal exception safety also known as no-leak guarantee: Partial execution of failed operations may store invalid data but will not cause a crash, and no resources get leaked.
No exception safety: No guarantees are made. (Worst level of exception safety)

For instance, consider a smart vector type, such as C++'s std::vector or Java's ArrayList. When an item x is added to a vector v, the vector must actually add x to the internal list of objects and also update a count field that says how many objects are in v. It may also need to allocate new memory if the existing capacity isn't large enough. This memory allocation may fail and throw an exception. Because of this, a vector that provides failure transparency would be very difficult or impossible to write. However, the vector may be able to offer the strong exception guarantee fairly easily; in this case, either the insertion of x into v will succeed, or v will remain unchanged. If the vector provides only the basic exception safety guarantee, if the insertion fails, v may or may not contain x, but at least it will be in a consistent state. However, if the vector makes only the minimal guarantee, it's possible that the vector may be invalid. For instance, perhaps the size field of v was incremented but x wasn't actually inserted, making the state inconsistent. Of course, with no guarantee, the program may crash; perhaps the vector needed to expand but couldn't allocate the memory and blindly ploughs ahead as if the allocation succeeded, touching memory at an invalid address.
Usually at least basic exception safety is required. Failure transparency is difficult to implement, and is usually not possible in libraries where complete knowledge of the application is not available.

[edit] Verification of Exception Handling
The point of exception handling routines is to ensure that the code can handle error conditions. In order to establish that exception handling routines are sufficiently robust, it is necessary to present the code with a wide spectrum of invalid or unexpected inputs, such as can be created via software fault injection and mutation testing (which is also sometimes referred to as fuzz testing). One of the most difficult types of software for which to write exception handling routines is protocol software, since a robust protocol implementation must be prepared to receive input that does not comply with the relevant specification(s).
In order to ensure that meaningful regression analysis can be conducted throughout a software development lifecycle process, any exception handling verification should be highly automated, and the test cases must be generated in a scientific, repeatable fashion. Several commercially available systems exist that perform such testing, including the Service Assurance Platform from Mu Dynamic which can verify exception handling for many common protocol implementation.

[edit] Exception support in programming languages
See also: Exception handling syntax
Many computer languages, such as most .NET languages, Actionscript, Ada, C++, D, ECMAScript, Eiffel, Java, ML, Object Pascal (e.g. Delphi, Free Pascal, and the like), Objective-C, Ocaml, PHP (as of version 5), PL/1, Prolog, Python, REALbasic, Ruby, Visual Prolog, have built-in support for exceptions and exception handling. In those languages, the advent of an exception (more precisely, an exception handled by the language) unwinds the stack of function calls until an exception handler is found. That is, if function f contains a handler H for exception E, calls function g, which in turn calls function h, and an exception E occurs in h, then functions h and g will be terminated, and H in f will handle E. Excluding minor syntactic differences, there are only a couple of exception handling styles in use. In the most popular style, an exception is initiated by a special statement (throw, or raise) with an exception object (e.g. with Java or Object Pascal) or a value of a special extendable enumerated type (e.g. with Ada). The scope for exception handlers starts with a marker clause (try, or the language's block starter such as begin) and ends in the start of the first handler clause (catch, except, rescue). Several handler clauses can follow, and each can specify which exception types it handles and what name it uses for the exception object. A few languages also permit a clause (else) that is used in case no exception occurred before the end of the handler's scope was reached. More common is a related clause (finally, or ensure) that is executed whether an exception occurred or not, typically to release resources acquired within the body of the exception-handling block. Notably, C++ does not need and does not provide this construct, and the Resource-Acquisition-Is-Initialization technique is used to free such resources instead. In its whole, exception handling code might look like this (in Java-like pseudocode; note that an exception type called EmptyLineException would need to be declared somewhere):


 try {
	line = console.readLine();
	if (line.length() == 0) {
		throw new EmptyLineException("The line read from console was empty!");
	}
	console.printLine("Hello %s!" % line);
	console.printLine("The program ran successfully");
 } catch (EmptyLineException e) {
	console.printLine("Hello!");
 } catch (Exception e) {
	console.printLine("Error: " + e.message());
 } finally {
	console.printLine("The program terminates now");
 }

As a minor variation, some languages use a single handler clause, which deals with the class of the exception internally.
Languages such as Perl and C don't use the term exception handling, but include facilities that allow implementing similar functionality.
The C++ derivative Embedded C++ excludes exception handling support as it can substantially increase the size of the object code.

[edit] Exception handling based on Design by Contract
A different view of exceptions is based on the principles of Design by Contract and is supported in particular by the Eiffel language. The idea is to provide a more rigorous basis for exception handling by defining precisely what is "normal" and "abnormal" behavior. Specifically, the approach is based on two concepts:

Failure: the inability of an operation to fulfill its contract. For example an addition may produce an arithmetic overflow (it does not fulfill its contract of computing a good approximation to the mathematical sum); or a routine may fail to meet its postcondition.
Exception: an abnormal event occurring during the execution of a routine (that routine is the "recipient" of the exception) during its execution. Such an abnormal event results from the failure of an operation called by the routine.

The "Safe Exception Handling principle" as introduced by Bertrand Meyer in Object-Oriented Software Construction then holds that there are only two meaningful ways a routine can react when an exception occurs:

Failure, or "organized panic": the routine fails, triggering an exception in its caller (so that the abnormal event is not ignored!), after fixing the object's state by re-establishing the invariant (the "organized" part).
Retry: try the algorithm again, usually after changing some values so that the next attempt will have a better chance to succeed.

Here is an example expressed in Eiffel syntax. It assumes that a routine send_fast is normally the better way to send a message, but it may fail, triggering an exception; if so, the algorithm next uses send_slow, which will fail less often. If send_slow fails, the routine send as a whole should fail, causing the caller to get an exception.


send (m: MESSAGE) is
	-- Send m through fast link if possible, otherwise through slow link.
local
	tried_fast, tried_slow: BOOLEAN
do
	if tried_fast then
	   tried_slow := True
	   send_slow (m)
	else
	   tried_fast := True
	   send_fast (m)
	end
rescue
	if not tried_slow then
	   retry
	end
end

The boolean local variables are initialized to False at the start. If send_fast fails, the body (do clause) will be executed again, causing execution of send_slow. If this execution of send_slow fails, the rescue clause will execute to the end with no retry (no else clause in the final if), causing the routine execution as a whole to fail.
This approach has the merit of defining clearly what a "normal" and "abnormal" cases are: an abnormal case, causing an exception, is one in which the routine is unable to fulfill its contract.
It defines a clear distribution of roles: the do clause (normal body) is in charge of achieving, or attempting to achieve, the routine's contract; the rescue clause is in charge of reestablishing the context and restarting the process if this has a chance of succeeding, but not of performing any actual computation.

[edit] Checked exceptions
The designers of Java devised[3][4] checked exceptions[5], which are a special set of exceptions. The checked exceptions that a method may raise are part of the method's signature. For instance, if a method might throw an IOException, it must declare this fact explicitly in its method signature. Failure to do so raises a compile-time error.
This is related to exception checkers that exist at least for OCaml[6]. The external tool for OCaml is both transparent (i.e. it does not require any syntactic annotations) and facultative (i.e. it is possible to compile and run a program without having checked the exceptions, although this is not suggested for production code).
The CLU programming language had a feature with the interface closer to what Java has introduced later. A function could raise only exceptions listed in its type, but any leaking exceptions from called functions would automatically be turned into the sole runtime exception, failure, instead of resulting in compile-time error. Later, Modula-3 had a similar feature.[7] These features don't include the compile time checking which is central in the concept of checked exceptions, and hasn't (as of 2006) been incorporated into major programming languages other than Java.[8]

[edit] Pros and cons
Checked exceptions can, at compile time, greatly reduce (but not entirely eliminate) the incidence of unhandled exceptions surfacing at runtime in a given application[citation needed]; the unchecked exceptions (RuntimeExceptions and Errors) can still go unhandled.
However, some see checked exceptions as a nuisance, syntactic salt that either requires large throws declarations, often revealing implementation details and reducing encapsulation, or encourages the (ab)use of poorly-considered try/catch blocks that can potentially hide legitimate exceptions from their appropriate handlers. The problem is more evident considering what happens to code over time. An interface may be declared to throw exceptions X & Y. In a later version of the code, if one wants to throw exception Z, it would make the new code incompatible with the earlier uses. Furthermore, with the adapter pattern, where one body of code declares an interface that is then implemented by a different body of code so that code can be plugged in and called by the first, the adapter code may have a rich set of exceptions to describe problems, but is forced to use the exception types declared in the interface.
Others do not consider this a nuisance as it is possible to reduce the number of declared exceptions by either declaring a superclass of all potentially thrown exceptions or by defining and declaring exception types that are suitable for the level of abstraction of the called method,[9] and mapping lower level exceptions to these types, preferably wrapped using the exception chaining in order to preserve the root cause. In addition, it's very possible that in the example above of the changing interface that the calling code would need to be modified as well, since in some sense the exceptions a method may throw are part of the method's implicit interface anyway.
A simple throws Exception declaration or catch (Exception e) is always sufficient to satisfy the checking. While this technique is sometimes useful, it effectively circumvents the checked exception mechanism, so it should only be used after careful consideration. Additionally, throws Exception forces all calling code to do the same.
One prevalent view is that unchecked exception types should not be handled, except maybe at the outermost levels of scope, as they often represent scenarios that do not allow for recovery: RuntimeExceptions frequently reflect programming defects,[10] and Errors generally represent unrecoverable JVM failures. The view is that, even in a language that supports checked exceptions, there are cases where the use of checked exceptions is not appropriate.

[edit] Exception synchronity
Somewhat related with the concept of checked exceptions is exception synchronity. Synchronous exceptions happen at a specific program statement whereas asynchronous exceptions can raise practically anywhere.[11][12] It follows that asynchronous exception handling can't be required by the compiler. They are also difficult to program with. Examples of naturally asynchronous events include pressing Ctrl-C to interrupt a program, and receiving a signal such as "stop" or "suspend" from another thread of execution.
Programming languages typically deal with this by limiting asynchronity, for example Java has lost thread stopping and resuming.[13] Instead, there can be semi-asynchronous exceptions that only raise in suitable locations of the program or synchronously.

[edit] Condition systems
Common Lisp, Dylan and Smalltalk have a Condition system which encompasses the aforementioned exception handling systems. In those languages or environments the advent of a condition (a "generalisation of an error" according to Kent Pitman) implies a function call, and only late in the exception handler the decision to unwind the stack may be taken.
Conditions are a generalization of exceptions. When a condition arises, an appropriate condition handler is searched for and selected, in stack order, to handle the condition. Conditions which do not represent errors may safely go unhandled entirely; their only purpose may be to propagate hints or warnings toward the user.[14]

[edit] Continuable exceptions
This is related to the so-called resumption model of exception handling, in which some exceptions are said to be continuable: it is permitted to return to the expression that signaled an exception, after having taken corrective action in the handler. The condition system is generalized thus: within the handler of a non-serious condition (a.k.a. continuable exception), it is possible to jump to predefined restart points (a.k.a. restarts) that lie between the signaling expression and the condition handler. Restarts are functions closed over some lexical environment, allowing the programmer to repair this environment before exiting the condition handler completely or unwinding the stack even partially.

[edit] Restarts separate mechanism from policy
Condition handling moreover provides a separation of mechanism from policy. Restarts provide various possible mechanisms for recovering from error, but do not select which mechanism is appropriate in a given situation. That is the province of the condition handler, which (since it is located in higher-level code) has access to a broader view.
An example: Suppose there is a library function whose purpose is to parse a single syslog file entry. What should this function do if the entry is malformed? There is no one right answer, because the same library could be deployed in programs for many different purposes. In an interactive log-file browser, the right thing to do might be to return the entry unparsed, so the user can see it -- but in an automated log-summarizing program, the right thing to do might be to supply null values for the unreadable fields, but abort with an error if too many entries have been malformed.
That is to say, the question can only be answered in terms of the broader goals of the program, which are not known to the general-purpose library function. Nonetheless, exiting with an error message is only rarely the right answer. So instead of simply exiting with an error, the function may establish restarts offering various ways to continue -- for instance, to skip the log entry, to supply default or null values for the unreadable fields, to ask the user for the missing values, or to unwind the stack and abort processing with an error message. The restarts offered constitute the mechanisms available for recovering from error; the selection of restart by the condition handler supplies the policy.

[edit] See also

Abrahams guarantees
setjmp/longjmp
Triple fault
Vectored Exception Handling (VEH)


[edit] References


^ All Exceptions Are Handled, Jim Wilcox, http://poliTechnosis.kataire.com/2008/02/all-exceptions-are-handled.html
^ http://www.open-std.org/jtc1/sc22/wg21/docs/papers/1997/N1077.asc
^ LISTSERV 15.0 - RMI-USERS Archives
^ Google Answers: The origin of checked exceptions
^ Java Language Specification, chapter 11.2. http://java.sun.com/docs/books/jls/third_edition/html/exceptions.html#11.2
^ [http://caml.inria.fr/pub/old_caml_site/ocamlexc/ocamlexc.htm OcamlExc -- An uncaught exceptions analyzer for Objective Caml]
^ Modula-3 - Procedure Types
^ Bruce Eckel's MindView, Inc: Does Java need Checked Exceptions?
^ Bloch 2001:178 Bloch, Joshua (2001). Effective Java Programming Language Guide. Addison-Wesley Professional. ISBN 0-201-31005-8. 
^ Bloch 2001:172
^ Asynchronous Exceptions in Haskell - Marlow, Jones, Moran (ResearchIndex)
^ Safe asynchronous exceptions for Python. http://www.cs.williams.edu/~freund/papers/02-lwl2.ps
^ Java Thread Primitive Deprecation
^ Condition System Concepts



[edit] External links

Article "PHP exception handling" by Christopher Hill
Article "Unchecked Exceptions - The Controversy"
Article "Practical C++ Error Handling in Hybrid Environments" by Gigi Sayfan
Article "C++ Exception Handling" by Christophe de Dinechin
Article "Compiling Exceptions Correctly" by Graham Hutton and Joel Wright
Article "Exceptional practices" by Brian Goetz
Article "Programming with Exceptions in C++" by Kyle Loudon
Article "Object Oriented Exception Handling in Perl" by Arun Udaya Shankar
Article "How to Implement Software Exception Handling"
Article "Exception Handling in C without C++" by Tom Schotland and Peter Petersen
Article "Structured Exception Handling Basics" by Vadim Kokielov
Article "All Exceptions Are Handled" by James "Jim" Wilcox
Article "An Exceptional Philosophy" by John M. Dlugosz
Paper "Exception Handling in Petri-Net-based Workflow Management" by Gert Faustmann and Dietmar Wikarski
Paper "Zero-Overhead Exception Handling Using Metaprogramming"
Overview for Smalltalk
Descriptions from Portland Pattern Repository
A Crash Course on the Depths of Win32 Structured Exception Handling by Matt Pietrek - Microsoft Systems Journal (1997)
The Trouble with Checked Exceptions - a conversation with Anders Hejlsberg
Does Java Need Checked Exceptions?
Problems and Benefits of Exception Handling
Understanding and Using Exceptions in .NET
Java Exception Handling - Jakob Jenkov
C++ Exception Handling - Danny Kalev
Visual Prolog Exception Handling (wiki article)
Type of Java Exceptions




Retrieved from "http://en.wikipedia.org/wiki/Exception_handling"
Categories: Control flow | Software anomaliesHidden categories: All articles with unsourced statements | Articles with unsourced statements since August 2007 






Views


Article
Discussion
Edit this page
History 



Personal tools


Log in / create account






 if (window.isMSIE55) fixalpha(); 

Navigation


Main page
Contents
Featured content
Current events
Random article




Search




 
				




Interaction


About Wikipedia
Community portal
Recent changes
Contact Wikipedia
Donate to Wikipedia
Help




Toolbox


What links here
Related changes
Upload file
Special pages
Printable version Permanent linkCite this page 



Languages


Deutsch
Español
فارسی
Français
한국어
Íslenska
Italiano
עברית
Magyar
Nederlands
日本語
Polski
Português
Русский
Српски / Srpski
Suomi
Svenska
தமிழ்
Українська









 This page was last modified on 4 March 2009, at 01:20.
All text is available under the terms of the GNU Free Documentation License. (See Copyrights for details.)  Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a U.S. registered 501(c)(3) tax-deductible nonprofit charity.
Privacy policy
About Wikipedia
Disclaimers



if (window.runOnloadHook) runOnloadHook();
